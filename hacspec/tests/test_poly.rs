use hacspec::prelude::*;

#[test]
fn test_zn_inv() {
    let n = 65537;
    assert_eq!(u128::inv(23647, n), 52791);
    assert_eq!(u128::inv(37543865, n), 37686);
    let n = 106103;
    assert_eq!(u128::inv(8752725684352, n), 52673);
    assert_eq!(u128::inv(123, n), 99202);

    let n = 106103i128;
    assert_eq!(i128::inv(-123, n), 6901);
}

#[test]
fn test_poly_add() {
    // Polynomials without irreducible and without coefficient modulus.
    poly!(Zx, u128, 256, 0, &[(0, 0)]);
    poly!(Zs, i128, 256, 0, &[(0, 0)]);

    let a = Zx::new(&[(78, 1), (222, 1)]);
    let b = Zx::new(&[(0, 1), (222, 2)]);
    let e = Zx::new(&[(0, 1), (78, 1), (222, 3)]);
    let c = a + b;
    println!("{:x?} + {:x?} = {:x?}\nexpected: {:x?}", a, b, c, e);
    assert_eq!(c, e);

    let a = Zs::new(&[(0, -1), (78, 1)]);
    let b = Zs::new(&[(0, 1), (78, 0), (222, -5)]);
    let e = Zs::new(&[(78, 1), (222, -5)]);
    let c = a + b;
    println!("{:x?} + {:x?} = {:x?}\nexpected: {:x?}", a, b, c, e);
    assert_eq!(c, e);

    // Polynomials without irreducible but with coefficient modulus.
    poly!(ZxN, u128, 256, 3, &[(0, 0)]);
    poly!(ZsN, i128, 256, 3, &[(0, 0)]);

    let a = ZxN::new(&[(78, 1), (222, 1)]);
    let b = ZxN::new(&[(0, 1), (222, 2)]);
    let e = ZxN::new(&[(0, 1), (78, 1)]);
    let c = a + b;
    println!("{:x?} + {:x?} = {:x?}\nexpected: {:x?}", a, b, c, e);
    assert_eq!(c, e);

    let a = ZsN::new(&[(0, -1), (78, 1)]);
    let b = ZsN::new(&[(0, 1), (222, -5)]);
    let e = ZsN::new(&[(78, 1), (222, 1)]);
    let c = a + b;
    println!("{:x?} + {:x?} = {:x?}\nexpected: {:x?}", a, b, c, e);
    assert_eq!(c, e);
}

// #[test]
// fn test_poly_sub() {
// }

#[test]
fn test_poly_div() {
    const l: usize = 3;
    poly!(ZxN, u128, l, 3, &[(0, 2), (1, 2), (3, 1)]);
    poly!(ZsN, i128, l, 3, &[(0, 2), (1, 2), (3, 1)]);

    let x = ZxN::new(&[(0, 1), (2, 2)]);
    let y = ZxN::new(&[(1, 1), (2, 1)]);
    let expected_c = ZxN::new(&[(0, 2)]);
    let expected_r = ZxN::new(&[(0, 1), (1, 1)]);

    let (c, r) = x / y;
    println!("{:x?} / {:x?} = {:x?}, {:x?}", x, y, c, r);
    assert_eq!(c, expected_c);
    assert_eq!(r, expected_r);

    let x = ZsN::new(&[(0, 1), (2, 2)]);
    let y = ZsN::new(&[(1, 1), (2, 1)]);
    let expected_c = ZsN::new(&[(0, 2)]);
    let expected_r = ZsN::new(&[(0, 1), (1, 1)]);

    let (c, r) = x / y;
    println!("{:x?} / {:x?} = {:x?}, {:x?}", x, y, c, r);
    assert_eq!(c, expected_c);
    assert_eq!(r, expected_r);
}

#[test]
fn test_poly_mul() {
    const l: usize = 3;
    poly!(ZxN, u128, l, 11, &[(0, 2), (1, 2), (3, 1)]);
    poly!(ZsN, i128, l, 11, &[(0, 2), (1, 2), (3, 1)]);

    let x = ZxN::new(&[(0, 1), (2, 2)]);
    let y = ZxN::new(&[(1, 1), (2, 1)]);
    let expected = ZxN::new(&[(0, 7), (1, 4), (2, 8)]);

    let c = x * y;
    println!("{:x?} * {:x?} = {:x?}", x, y, c);
    assert_eq!(c, expected);

    let x = ZsN::new(&[(0, 1), (2, 2)]);
    let y = ZsN::new(&[(1, 1), (2, 1)]);
    let expected = ZsN::new(&[(0, 7), (1, 4), (2, 8)]);

    let c = x * y;
    println!("{:x?} * {:x?} = {:x?}", x, y, c);
    assert_eq!(c, expected);

    let x = ZsN::new(&[(0, -3), (1, 5), (2, -1)]);
    let y = ZsN::new(&[(0, 1), (1, -2), (2, -7)]);
    let expected = ZsN::new(&[(0, 8), (1, 8), (2, 7)]);

    let c = x * y;
    println!("{:x?} * {:x?} = {:x?}", x, y, c);
    assert_eq!(c, expected);

    // Use random values, so no expected value possible here.
    // poly!(ZxLarge, u128, 592_358, 86_028_121, &[(0, 2), (1, 2), (3, 1)]);
    // let a = ZxN::random();
    // let b = ZxN::random();
    // let r = a * b;
    // println!("{:x?} * {:x?} = {:x?}", a, b, r);
}

#[test]
fn test_poly_inversion() {
    const l: usize = 3;
    poly!(ZxN, u128, l, 3, &[(0, 2), (1, 2), (3, 1)]);
    // TODO: Signed inversion?
    let one_poly = ZxN::new(&[(0, 1)]);

    let a = ZxN::new(&[(0, 2), (1, 2)]);
    let a_inv = a.inv();
    let test = a * a_inv;
    assert_eq!(test, one_poly);
    
    let a = ZxN::new(&[(0, 1), (1, 2), (2, 2)]);
    let a_inv = a.inv();
    let test = a * a_inv;
    assert_eq!(test, one_poly);
    
    let a = ZxN::new(&[(2, 1)]);
    let a_inv = a.inv();
    let test = a * a_inv;
    assert_eq!(test, one_poly);
}

#[test]
#[should_panic]
fn test_poly_inversion_panic() {
    poly!(ZxN, u128, 11, 3, &[(0, 2), (1, 2), (2, 1), (3, 2), (4, 2), (5, 1), (6, 2), (8, 2), (10, 2), (11, 2)]);
    // Not invertible
    // let irr = [2, 2, 1, 2, 2, 1, 2, 0, 2, 0, 2, 2];
    let a = ZxN::new_full([0, 1, 2, 0, 2, 2, 0, 0, 2, 0, 0]);
    let _ = a.inv();
}

// Rq = Z[X]/(3329, (X^256+1))
poly!(RqKyberFixedLength, u128, 256, 3329, &[(0, 1), (256, 1)]);

#[test]
fn test_fixed_length() {
    let a = RqKyberFixedLength::new(&[(0, 1), (5, 55), (77, 123)]);
    // let b = RqKyberFixedLength::random();
    // let c = a * b;
    // println!("{:x?} * {:x?} = {:x?}", a, b, c);

    let b = RqKyberFixedLength::new_full([0x72a, 0x50b, 0x6db, 0x26e, 0x536, 0x253, 0x292, 0x42f, 0x2da, 0x92b, 0x9b4, 0xbfc, 0x263, 0x636, 0x78b, 0x82e, 0x54a, 0x8cf, 0xc3, 0xa30, 0x99e, 0x2f4, 0x696, 0x2be, 0x2a6, 0x159, 0x147, 0x4b, 0xa44, 0x255, 0x9c5, 0x1a7, 0xa61, 0x640, 0xca3, 0xb51, 0x761, 0xbf2, 0x210, 0x25e, 0xa90, 0x25b, 0x1ab, 0x5e5, 0x7a2, 0x235, 0x9d0, 0x373, 0x55, 0xc46, 0x1c3, 0x90a, 0x21b, 0xa0d, 0x73e, 0x6ce, 0x4b4, 0x355, 0x681, 0x667, 0x8a0, 0x3e, 0xb79, 0x190, 0xbab, 0x137, 0xb43, 0x493, 0x399, 0x8e8, 0x731, 0x24b, 0x43f, 0x9ef, 0x206, 0x5d4, 0x252, 0x9da, 0x449, 0xa34, 0xc13, 0x5c2, 0x6f, 0x1d1, 0x397, 0x6f7, 0xc9c, 0x736, 0x95a, 0x6ef, 0x724, 0x25b, 0xcec, 0x784, 0xab5, 0xbc2, 0x12f, 0x5ff, 0x834, 0x34e, 0x282, 0x47d, 0x874, 0x46e, 0xced, 0x682, 0x329, 0x5ab, 0x7ca, 0x3df, 0xcd6, 0x412, 0x444, 0xa7e, 0xc61, 0x9b1, 0xa59, 0x612, 0x2bc, 0x391, 0xd, 0xa48, 0x46c, 0xa9a, 0xc7b, 0x4a4, 0x873, 0xc48, 0x114, 0x8a6, 0x666, 0xad9, 0x5ce, 0x13f, 0x88d, 0x4c3, 0xae6, 0x9fe, 0x548, 0x8f8, 0x422, 0x653, 0x67a, 0x39a, 0x57e, 0xa95, 0x33, 0x76d, 0x101, 0xc89, 0xbd, 0x8b0, 0x146, 0x916, 0x5d, 0x577, 0x278, 0x16a, 0x6e, 0x558, 0xc59, 0xce4, 0x7f0, 0xbe5, 0x6c7, 0x84b, 0xac4, 0x8c1, 0x5b5, 0xd7, 0x993, 0x207, 0xb74, 0xf1, 0x926, 0x75c, 0x8c3, 0x1c4, 0x86d, 0x9ee, 0x380, 0x32a, 0x8dd, 0x56, 0x747, 0x20c, 0x737, 0x596, 0x292, 0x811, 0x4a8, 0x4f2, 0xb45, 0x158, 0x226, 0xc72, 0x99a, 0x1cd, 0x520, 0x6b1, 0x250, 0xbbb, 0x140, 0x476, 0x5e8, 0x45, 0x3a, 0x708, 0x3f1, 0x32a, 0xa6a, 0x694, 0x2f4, 0x39e, 0x5ad, 0xb2b, 0x7e1, 0xb5c, 0xe1, 0xc64, 0x1f3, 0x90b, 0x67a, 0x66c, 0x478, 0x647, 0x227, 0x26, 0x912, 0x581, 0x666, 0x884, 0x879, 0x30c, 0x142, 0x8c5, 0x72d, 0x3da, 0x48a, 0x15b, 0xca0, 0x284, 0x4e7, 0x6cc, 0x7ad, 0x29b, 0x3be, 0x63f, 0x655, 0x22a, 0x12f, 0x32b, 0x898, 0xaa1, 0xc3, 0x9fc]);
    let c = a * b;
    let expected_c = RqKyberFixedLength::new_full([766, 3113, 2145, 433, 3310, 2147, 553, 246, 2197, 1441, 928, 2499, 339, 3140, 2150, 1155, 1259, 3175, 981, 701, 145, 2410, 2688, 2028, 323, 3043, 130, 2446, 2933, 334, 1742, 87, 2719, 3217, 2068, 1681, 3068, 972, 493, 1051, 1584, 3173, 387, 3052, 2851, 1915, 1137, 3201, 1839, 1443, 1366, 2251, 678, 123, 2157, 257, 2144, 958, 1928, 631, 2073, 1646, 601, 861, 2285, 3229, 819, 1595, 2681, 472, 739, 2039, 2358, 2312, 962, 2195, 1456, 1595, 145, 621, 1865, 1815, 2279, 1916, 5, 1916, 131, 557, 2524, 971, 2511, 2860, 2868, 526, 1554, 1033, 1378, 267, 1168, 2776, 2863, 1338, 2522, 392, 2471, 688, 946, 1982, 3207, 460, 2093, 685, 1129, 1816, 1038, 1809, 1337, 1384, 2885, 1357, 2491, 2505, 2963, 645, 2227, 2371, 749, 1033, 1398, 1219, 622, 239, 2508, 470, 2506, 3152, 919, 2998, 3220, 1237, 788, 3146, 835, 450, 2070, 1074, 17, 3279, 3324, 1184, 2571, 2163, 2103, 2969, 760, 249, 1471, 2334, 3074, 162, 812, 1292, 1563, 1, 1094, 1051, 3101, 2616, 88, 3174, 2994, 3208, 396, 1350, 3232, 2167, 1686, 990, 276, 1373, 981, 1871, 2346, 1843, 562, 2114, 1840, 1092, 394, 2487, 858, 3275, 534, 2829, 2328, 1712, 1292, 943, 1081, 1420, 307, 1867, 2020, 3122, 3063, 3326, 1446, 1160, 2581, 428, 2421, 1143, 18, 111, 1105, 2859, 868, 1514, 617, 727, 1501, 3223, 2113, 318, 3289, 741, 3259, 1289, 104, 1228, 3273, 647, 3228, 3157, 2499, 2666, 378, 3076, 547, 1673, 1892, 2158, 359, 1829, 412, 1927, 2901, 2578, 1366, 3205, 51, 2009, 2293, 1575, 3036, 1567]);
    println!("{:x?} * {:x?} = {:x?}", a, b, c);
    assert_eq!(c, expected_c);
}

// Rq = Z[X]/(3329, (X^256+1))
poly!(RqKyberSecret, U128, 256, U128(3329), &[(0, U128(1)), (256, U128(1))]);

#[test]
fn test_secret() {
    let a = RqKyberSecret::new(&[(0, U128(1)), (5, U128(55)), (77, U128(123))]);
    // let b = RqKyberFixedLength::random();
    // let c = a * b;
    // println!("{:x?} * {:x?} = {:x?}", a, b, c);

    let b = RqKyberSecret::new_full([U128(0x72a), U128(0x50b), U128(0x6db), U128(0x26e), U128(0x536), U128(0x253), U128(0x292), U128(0x42f), U128(0x2da), U128(0x92b), U128(0x9b4), U128(0xbfc), U128(0x263), U128(0x636), U128(0x78b), U128(0x82e), U128(0x54a), U128(0x8cf), U128(0xc3), U128(0xa30), U128(0x99e), U128(0x2f4), U128(0x696), U128(0x2be), U128(0x2a6), U128(0x159), U128(0x147), U128(0x4b), U128(0xa44), U128(0x255), U128(0x9c5), U128(0x1a7), U128(0xa61), U128(0x640), U128(0xca3), U128(0xb51), U128(0x761), U128(0xbf2), U128(0x210), U128(0x25e), U128(0xa90), U128(0x25b), U128(0x1ab), U128(0x5e5), U128(0x7a2), U128(0x235), U128(0x9d0), U128(0x373), U128(0x55), U128(0xc46), U128(0x1c3), U128(0x90a), U128(0x21b), U128(0xa0d), U128(0x73e), U128(0x6ce), U128(0x4b4), U128(0x355), U128(0x681), U128(0x667), U128(0x8a0), U128(0x3e), U128(0xb79), U128(0x190), U128(0xbab), U128(0x137), U128(0xb43), U128(0x493), U128(0x399), U128(0x8e8), U128(0x731), U128(0x24b), U128(0x43f), U128(0x9ef), U128(0x206), U128(0x5d4), U128(0x252), U128(0x9da), U128(0x449), U128(0xa34), U128(0xc13), U128(0x5c2), U128(0x6f), U128(0x1d1), U128(0x397), U128(0x6f7), U128(0xc9c), U128(0x736), U128(0x95a), U128(0x6ef), U128(0x724), U128(0x25b), U128(0xcec), U128(0x784), U128(0xab5), U128(0xbc2), U128(0x12f), U128(0x5ff), U128(0x834), U128(0x34e), U128(0x282), U128(0x47d), U128(0x874), U128(0x46e), U128(0xced), U128(0x682), U128(0x329), U128(0x5ab), U128(0x7ca), U128(0x3df), U128(0xcd6), U128(0x412), U128(0x444), U128(0xa7e), U128(0xc61), U128(0x9b1), U128(0xa59), U128(0x612), U128(0x2bc), U128(0x391), U128(0xd), U128(0xa48), U128(0x46c), U128(0xa9a), U128(0xc7b), U128(0x4a4), U128(0x873), U128(0xc48), U128(0x114), U128(0x8a6), U128(0x666), U128(0xad9), U128(0x5ce), U128(0x13f), U128(0x88d), U128(0x4c3), U128(0xae6), U128(0x9fe), U128(0x548), U128(0x8f8), U128(0x422), U128(0x653), U128(0x67a), U128(0x39a), U128(0x57e), U128(0xa95), U128(0x33), U128(0x76d), U128(0x101), U128(0xc89), U128(0xbd), U128(0x8b0), U128(0x146), U128(0x916), U128(0x5d), U128(0x577), U128(0x278), U128(0x16a), U128(0x6e), U128(0x558), U128(0xc59), U128(0xce4), U128(0x7f0), U128(0xbe5), U128(0x6c7), U128(0x84b), U128(0xac4), U128(0x8c1), U128(0x5b5), U128(0xd7), U128(0x993), U128(0x207), U128(0xb74), U128(0xf1), U128(0x926), U128(0x75c), U128(0x8c3), U128(0x1c4), U128(0x86d), U128(0x9ee), U128(0x380), U128(0x32a), U128(0x8dd), U128(0x56), U128(0x747), U128(0x20c), U128(0x737), U128(0x596), U128(0x292), U128(0x811), U128(0x4a8), U128(0x4f2), U128(0xb45), U128(0x158), U128(0x226), U128(0xc72), U128(0x99a), U128(0x1cd), U128(0x520), U128(0x6b1), U128(0x250), U128(0xbbb), U128(0x140), U128(0x476), U128(0x5e8), U128(0x45), U128(0x3a), U128(0x708), U128(0x3f1), U128(0x32a), U128(0xa6a), U128(0x694), U128(0x2f4), U128(0x39e), U128(0x5ad), U128(0xb2b), U128(0x7e1), U128(0xb5c), U128(0xe1), U128(0xc64), U128(0x1f3), U128(0x90b), U128(0x67a), U128(0x66c), U128(0x478), U128(0x647), U128(0x227), U128(0x26), U128(0x912), U128(0x581), U128(0x666), U128(0x884), U128(0x879), U128(0x30c), U128(0x142), U128(0x8c5), U128(0x72d), U128(0x3da), U128(0x48a), U128(0x15b), U128(0xca0), U128(0x284), U128(0x4e7), U128(0x6cc), U128(0x7ad), U128(0x29b), U128(0x3be), U128(0x63f), U128(0x655), U128(0x22a), U128(0x12f), U128(0x32b), U128(0x898), U128(0xaa1), U128(0xc3), U128(0x9fc)]);
    let c = a * b;
    let expected_c = RqKyberSecret::new_full([U128(766), U128(3113), U128(2145), U128(433), U128(3310), U128(2147), U128(553), U128(246), U128(2197), U128(1441), U128(928), U128(2499), U128(339), U128(3140), U128(2150), U128(1155), U128(1259), U128(3175), U128(981), U128(701), U128(145), U128(2410), U128(2688), U128(2028), U128(323), U128(3043), U128(130), U128(2446), U128(2933), U128(334), U128(1742), U128(87), U128(2719), U128(3217), U128(2068), U128(1681), U128(3068), U128(972), U128(493), U128(1051), U128(1584), U128(3173), U128(387), U128(3052), U128(2851), U128(1915), U128(1137), U128(3201), U128(1839), U128(1443), U128(1366), U128(2251), U128(678), U128(123), U128(2157), U128(257), U128(2144), U128(958), U128(1928), U128(631), U128(2073), U128(1646), U128(601), U128(861), U128(2285), U128(3229), U128(819), U128(1595), U128(2681), U128(472), U128(739), U128(2039), U128(2358), U128(2312), U128(962), U128(2195), U128(1456), U128(1595), U128(145), U128(621), U128(1865), U128(1815), U128(2279), U128(1916), U128(5), U128(1916), U128(131), U128(557), U128(2524), U128(971), U128(2511), U128(2860), U128(2868), U128(526), U128(1554), U128(1033), U128(1378), U128(267), U128(1168), U128(2776), U128(2863), U128(1338), U128(2522), U128(392), U128(2471), U128(688), U128(946), U128(1982), U128(3207), U128(460), U128(2093), U128(685), U128(1129), U128(1816), U128(1038), U128(1809), U128(1337), U128(1384), U128(2885), U128(1357), U128(2491), U128(2505), U128(2963), U128(645), U128(2227), U128(2371), U128(749), U128(1033), U128(1398), U128(1219), U128(622), U128(239), U128(2508), U128(470), U128(2506), U128(3152), U128(919), U128(2998), U128(3220), U128(1237), U128(788), U128(3146), U128(835), U128(450), U128(2070), U128(1074), U128(17), U128(3279), U128(3324), U128(1184), U128(2571), U128(2163), U128(2103), U128(2969), U128(760), U128(249), U128(1471), U128(2334), U128(3074), U128(162), U128(812), U128(1292), U128(1563), U128(1), U128(1094), U128(1051), U128(3101), U128(2616), U128(88), U128(3174), U128(2994), U128(3208), U128(396), U128(1350), U128(3232), U128(2167), U128(1686), U128(990), U128(276), U128(1373), U128(981), U128(1871), U128(2346), U128(1843), U128(562), U128(2114), U128(1840), U128(1092), U128(394), U128(2487), U128(858), U128(3275), U128(534), U128(2829), U128(2328), U128(1712), U128(1292), U128(943), U128(1081), U128(1420), U128(307), U128(1867), U128(2020), U128(3122), U128(3063), U128(3326), U128(1446), U128(1160), U128(2581), U128(428), U128(2421), U128(1143), U128(18), U128(111), U128(1105), U128(2859), U128(868), U128(1514), U128(617), U128(727), U128(1501), U128(3223), U128(2113), U128(318), U128(3289), U128(741), U128(3259), U128(1289), U128(104), U128(1228), U128(3273), U128(647), U128(3228), U128(3157), U128(2499), U128(2666), U128(378), U128(3076), U128(547), U128(1673), U128(1892), U128(2158), U128(359), U128(1829), U128(412), U128(1927), U128(2901), U128(2578), U128(1366), U128(3205), U128(51), U128(2009), U128(2293), U128(1575), U128(3036), U128(1567)]);
    println!("{:x?} * {:x?} = {:x?}", a, b, c);
    assert_eq!(c, expected_c);
}
