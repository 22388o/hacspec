\documentclass[11pt,a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{fullpage}
\usepackage{lmodern}
\usepackage{amsmath,amssymb}
\usepackage{mathpartir}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{csquotes}

\newcommand{\rustspec}{Rustspec}

\title{\rustspec{} formalization}

\author{Denis Merigoux}

\begin{document}
\maketitle

The formalization is close to \cite{radanne2019kindly}.

\section{Syntax}

%%%%%%%%%%%%%%%%%%% Syntax
\newcommand{\synvar}[1]{\ensuremath{#1}}
\newcommand{\syntext}[1]{\texttt{#1}}
\newcommand{\synkeyword}[1]{\textcolor{red!60!black}{\syntext{#1}}}
\newcommand{\synpunct}[1]{\textcolor{black!40!white}{\texttt{#1}}}

%% Keywords
\newcommand{\synuse}{\synkeyword{use}\;}
\newcommand{\synconst}{\synkeyword{const}\;}
\newcommand{\syntypalias}{\synkeyword{type}\;}
\newcommand{\synfn}{\synkeyword{fn}\;}
\newcommand{\synbool}{\synkeyword{bool}}
\newcommand{\synint}{\synkeyword{int}}
\newcommand{\synseq}{\syntext{Seq}}
\newcommand{\syncopy}{\syntext{Copy}}
\newcommand{\synclone}{\syntext{clone()}}
\newcommand{\synlet}{\synkeyword{let}\;}
\newcommand{\synmut}{\synkeyword{mut}}
\newcommand{\synif}{\synkeyword{if}\;}
\newcommand{\synthen}{\;\synkeyword{then}\;}
\newcommand{\synelse}{\;\synkeyword{else}\;}
\newcommand{\synfor}{\synkeyword{for}\;}
\newcommand{\synin}{\;\synkeyword{in}\;}
\newcommand{\syntrue}{\synkeyword{true}}
\newcommand{\synfalse}{\synkeyword{false}}

%%Macros
\newcommand{\synarraymacro}{\synkeyword{array!}}
\newcommand{\synpolymacro}{\synkeyword{poly!}}

%% Punctucation
\newcommand{\synsc}{\synpunct{;}}
\newcommand{\syntyped}{\;\synpunct{:}\;}
\newcommand{\syneq}{\;\synpunct{=}\;}
\newcommand{\synlparen}{\synpunct{(}\;}
\newcommand{\synrparen}{\;\synpunct{)}}
\newcommand{\syncomma}{\synpunct{,}\;}
\newcommand{\syndot}{\synpunct{.}}
\newcommand{\synref}{\synpunct{\&}}
\newcommand{\synand}{\;\synpunct{\&\&}\;}
\newcommand{\synor}{\;\synpunct{||}\;}
\newcommand{\synxor}{\;\synpunct{\^}\;}
\newcommand{\synadd}{\;\synpunct{+}\;}
\newcommand{\synminus}{\;\synpunct{-}\;}
\newcommand{\synmult}{\;\synpunct{*}\;}
\newcommand{\syndiv}{\;\synpunct{/}\;}
\newcommand{\synnot}{\synpunct{\~}\;}
\newcommand{\synlangle}{\synpunct{<}\;}
\newcommand{\synrangle}{\;\synpunct{>}}
\newcommand{\synlbracket}{\synpunct{\{}\;}
\newcommand{\synrbracket}{\;\synpunct{\}}}
\newcommand{\synarrow}{\;\synpunct{->}\;}
\newcommand{\synrange}{\;\synpunct{..}\;}
\newcommand{\synlsquare}{\synpunct{[}\;}
\newcommand{\synrsquare}{\;\synpunct{]}}
\newcommand{\synellipsis}{\synpunct{,\ldots,}\;}

%% BNF
\newcommand{\syndef}{$::=$}
\newcommand{\synalt}{\;$|$\;}

%%%%%%%%%%%%%%%%%%%% Typing

\newcommand{\typctx}[1]{\textcolor{green!50!black}{\ensuremath{#1}}}

\newcommand{\typempty}{\typctx{\varnothing}}
\newcommand{\typtyped}{\;\typctx{:}\;}
\newcommand{\typsc}{\typctx{;}\;}
\newcommand{\typcomma}{\typctx{,}\;}
\newcommand{\typarrow}{\typctx{\;\rightarrow}\;}
\newcommand{\typlparen}{\typctx{(}\;}
\newcommand{\typrparen}{\;\typctx{)}}
\newcommand{\typlsquare}{\typctx{[}\;}
\newcommand{\typrsquare}{\;\typctx{]}}
\newcommand{\typlangle}{\typctx{<}\;}
\newcommand{\typrangle}{\;\typctx{>}}
\newcommand{\typeq}{\;\typctx{=}\;}
\newcommand{\typcomp}{\;\typctx{\circ}\;}
\newcommand{\typellipsis}{\typctx{,\ldots,}\;}
\newcommand{\typderive}{\;\typctx{\vdash}\;}
\newcommand{\typsym}{\;\typctx{\sim}\;}
\newcommand{\typproduce}{\;\typctx{\Rrightarrow}\;}


The \rustspec{} language is a subset of Rust. Apart from the basic \synint{} and \synbool{} types,
the language operates on arrays of fixed size, known at compilation (\synarraymacro{}) or not
(\synseq). The biggest limitation compared to the full Rust language is the borrowing patterns
that we allow. Indeed, we restrict borrowing to only immutable borrowing (\synref{}),
and we also restrict where this borrowing can happen: only in function arguments or at function call
sites. Coupled to the fact that functions cannot return types containing immutable references,
this gives severely restrict the manipulation of linear types in the language.

\begin{center}
\begin{tabular}{lrrll}
Items&\synvar{i}&\syndef&\synarraymacro\synlparen\synvar{t}\syncomma\synvar{\mu}\syncomma $n\in\mathbb{N}$\synrparen\synsc&array type declaration\\
&&\synalt&\synfn\synvar{f}\synlparen$[$\synvar{d}$]^+$\synrparen\synarrow\synvar{\mu}\;\synlbracket$[$\synvar{s}$]^+$\synrbracket&function declaration\\
Argument declaration&\synvar{d}&\syndef&\synvar{x}\syntyped\synvar{\tau}&\\
Reference-free type&\synvar{\mu}&\syndef&\synbool\synalt\synint&base types\\
&&\synalt&\synseq\synlangle\synvar{\mu}\synrangle&sequence\\
&&\synalt&\synvar{t}&type variable\\
&&\synalt&\synlparen$[$\synvar{\mu}$]^+$\synrparen&tuple\\
Type&\synvar{\tau}&\syndef&\synvar{\mu}&base types\\
&&\synalt&\synref\synvar{\mu}&immutable reference\\
Statement&\synvar{s}&\syndef&\synlet$($\synmut$)$\;\synvar{x}\syntyped\synvar{\tau}\syneq\synvar{e}\synsc&let binding\\
&&\synalt&\synvar{x}\syneq\synvar{e}\synsc&mutable variable reassignment\\
&&\synalt&\synif\synvar{e}\synthen\synlbracket$[$\synvar{s}$]^+$\synrbracket\;$($\synelse\synlbracket$[$\synvar{s}$]^+$\synrbracket$)$\synsc&conditional statements\\
&&\synalt&\synfor\synvar{x}\synin\synvar{e}\synrange\synvar{e}\;\synlbracket$[$\synvar{s}$]^+$\synrbracket\synsc&for loop (integers only)\\
&&\synalt&\synvar{e}\synlsquare\synvar{e}\synrsquare\syneq\synvar{e}\synsc&array update\\
Expression&\synvar{e}&\syndef&\syntrue\synalt\synfalse&boolean literals\\
&&\synalt&$n\in\mathbb{N}$&integer literal\\
&&\synalt&\synvar{x}&variable\\
&&\synalt&\synvar{f}\synlparen$[$\synvar{a}$]^+$\synrparen&function call\\
&&\synalt&\synvar{e}\;\synvar{\odot}\;\synvar{e}&binary operations\\
&&\synalt&\synvar{\oslash}\;\synvar{e}&unary operations\\
&&\synalt&\synlparen $[$\synvar{e}$]^+$\synrparen&tuple constructor\\
&&\synalt&\synvar{e}\syndot$(n\in\mathbb{N})$&tuple field access\\
Function argument&\synvar{a}&\syndef&\synvar{e}&linear argument\\
&&\synalt&\synref\synvar{e}&call-site borrowing\\
Binary operators&\synvar{\odot}&\syndef&\synadd\synalt\synminus\synalt\synmult\synalt\syndiv\synalt\synand\synalt\synor\\
Unary operators&\synvar{\oslash}&\syndef&\synminus\synalt\synnot&
\end{tabular}
\end{center}

\section{Typing}

The typing environnement of \rustspec{} is fairly standard. We need a type dictionary to enforce
the named type discipline of Rust that covers the types declared by the \synarraymacro{} macro.

\begin{center}
\begin{tabular}{lrrll}
Typing context&\typctx{\Gamma}&\syndef&\typempty&empty context\\
&&\synalt& \synvar{x}\typtyped\synvar{\tau}\typcomma\typctx{\Gamma}&variable\\
&&\synalt& \synvar{f}\typtyped\typlparen$[$\synvar{\tau}$]^+$\typrparen\typarrow\synvar{\mu}\typcomma\typctx{\Gamma}&function\\
Type dictionary&\typctx{\Delta}&\syndef&\typempty&empty dictionnary\\
&&\synalt&\synvar{t}\typarrow\typlsquare\synvar{\tau}\typsc $n\in\mathbb{N}$\typrsquare\typcomma\typctx{\Delta}&array type\\
\end{tabular}
\end{center}

The restrictions on borrowing lead to severe limitations on how we can manipulate values
of linear type in our language, rendering it quite useless at first sight. However, in the spirit
of Rust, we introduce an escape hatch from linearity under the form of the \syncopy{} trait
implementation. This trait, that is primitive to the Rust language, is used to distinguish the values
that are \enquote{cheap} to copy. This concerns all the reference-free \synvar{\mu} types except \synseq, whose size is not known at compilation time (and thus can be arbitrarily large).
Paradoxically, \synarraymacro{} types that can be as large as their \synseq{} counterparts do benefit
from the \syncopy{} trait; we replicate here the behavior of Rust. The reason for that is that size
the lenght is known at compilation time, the code generation backend of Rust (LLVM) can optimize the
representation of the array in memory, especially if the size is small.

\begin{center}
\begin{tabular}{lc}\toprule
Implementing the \syncopy{} trait&\typctx{\Delta}\typderive\synvar{\tau}\typtyped\syncopy
\\\bottomrule
\end{tabular}
\begin{mathpar}
\inferrule[CopyBool]{
{}
}{
\typctx{\Delta}\typderive\synbool\typtyped\syncopy
}

\inferrule[CopyInt]{
{}
}{
\typctx{\Delta}\typderive\synint\typtyped\syncopy
}

\inferrule[CopyTuple]{
\typctx{\Delta}\typderive\synvar{\tau_1}\typtyped\syncopy\\
\cdots\\
\typctx{\Delta}\typderive\synvar{\tau_n}\typtyped\syncopy
}{
\typctx{\Delta}\typderive\typlparen\synvar{\tau_1}\typellipsis\synvar{\tau_n}\typrparen\typtyped\syncopy
}

\inferrule[CopyArray]{
\typctx{\Delta}\typderive\synvar{\tau}\typtyped\syncopy
}{
\synvar{t}\typarrow\typlsquare\synvar{\tau}\typsc n\typrsquare\typcomma\typctx{\Delta}\typderive\synvar{t}\typtyped\syncopy
}
\end{mathpar}
\end{center}

Because Rust has an affine type system, \rustspec{} also enjoys an affine typing context with
associated splitting rules (\TirName{SplitLinear}). Please note that immutable references values can be duplicated freely
in the context (\TirName{SplitDuplicable}). During an elaboration phase inside the Rust compiler, the linearity
of the type system gets circumvented for \syncopy{} values with the insertion of \synclone{} functions
call that perform a copy of the value wherever the linear type system forces a copy of the value to
be made. We formalize this behavior here by allowing \syncopy{} types duplication in the typing
context, like immutable references (\TirName{SplitCopy}). Lastly, functions are always duplicable in the context (\TirName{SplitFunction}).

\begin{center}
\begin{tabular}{lc}\toprule
Context splitting&\typctx{\Delta}\typderive\typctx{\Gamma}\typeq\typctx{\Gamma_1}\typcomp\typctx{\Gamma_2}
\\\bottomrule
\end{tabular}
\begin{mathpar}
\inferrule[SplitEmpty]{
{}
}{
\typctx{\Delta}\typderive\typempty\typeq\typempty\typcomp\typempty
}

\inferrule[SplitLinear1]{
\typctx{\Delta}\typderive\typctx{\Gamma}\typeq\typctx{\Gamma_1}\typcomp\typctx{\Gamma_2}
}{
\typctx{\Delta}\typderive\synvar{x}\typtyped\synvar{\tau}\typcomma\typctx{\Gamma}\typeq
\typlparen\synvar{x}\typtyped\synvar{\tau}\typcomma\typctx{\Gamma_1}\typrparen\typcomp
\typctx{\Gamma_2}
}

\inferrule[SplitLinear2]{
\typctx{\Delta}\typderive\typctx{\Gamma}\typeq\typctx{\Gamma_1}\typcomp\typctx{\Gamma_2}
}{
\typctx{\Delta}\typderive\synvar{x}\typtyped\synvar{\tau}\typcomma\typctx{\Gamma}\typeq
\typctx{\Gamma_1}\typcomp
\typlparen\synvar{x}\typtyped\synvar{\tau}\typcomma\typctx{\Gamma_2}\typrparen
}

\inferrule[SplitDuplicable]{
\typctx{\Delta}\typderive\typctx{\Gamma}\typeq\typctx{\Gamma_1}\typcomp\typctx{\Gamma_2}
}{
\typctx{\Delta}\typderive\synvar{x}\typtyped\synref\synvar{\tau}\typcomma\typctx{\Gamma}\typeq
\typlparen\synvar{x}\typtyped\synref\synvar{\tau}\typcomma\typctx{\Gamma_1}\typrparen\typcomp
\typlparen\synvar{x}\typtyped\synref\synvar{\tau}\typcomma\typctx{\Gamma_2}\typrparen
}

\inferrule[SplitCopy]{
\typctx{\Delta}\typderive\typctx{\Gamma}\typeq\typctx{\Gamma_1}\typcomp\typctx{\Gamma_2}\\
\typctx{\Delta}\typderive\synvar{\tau}\typtyped\syncopy
}{
\typctx{\Delta}\typderive\synvar{x}\typtyped\synvar{\tau}\typcomma\typctx{\Gamma}\typeq
\typlparen\synvar{x}\typtyped\synvar{\tau}\typcomma\typctx{\Gamma_1}\typrparen\typcomp
\typlparen\synvar{x}\typtyped\synvar{\tau}\typcomma\typctx{\Gamma_2}\typrparen
}

\inferrule[SplitFunction]{
\typctx{\Delta}\typderive\typctx{\Gamma}\typeq\typctx{\Gamma_1}\typcomp\typctx{\Gamma_2}
}{
\typctx{\Delta}\typderive\synvar{f}\typtyped\typlparen\typctx{\mu_1}\typellipsis\typctx{\mu_n}\typrparen\typarrow\synvar{\tau}\typcomma\typctx{\Gamma}\typeq
\typlparen\synvar{f}\typtyped\typlparen\typctx{\mu_1}\typellipsis\typctx{\mu_n}\typrparen\typarrow\synvar{\tau}\typcomma\typctx{\Gamma_1}\typrparen\typcomp
\typlparen\synvar{f}\typtyped\typlparen\typctx{\mu_1}\typellipsis\typctx{\mu_n}\typrparen\typarrow\synvar{\tau}\typcomma\typctx{\Gamma_2}\typrparen
}
\end{mathpar}
\end{center}

We can now proceed to the main typing judgments. Let us start with expressions.*
\TirName{TypVarLinear} and \TirName{TypVarDup} reflect the variable typing present in the context.
\TirName{TypTupleCons} only allows non-reference values inside a tuple, with a linear context
splitting to check each term of the tuple..

\begin{center}
\begin{tabular}{lc}\toprule
Expression typing&\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{e}\typtyped\synvar{\tau}\\
Function argument typing&\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{a}\typsym\synvar{\tau}
\\\bottomrule
\end{tabular}
\begin{mathpar}
\inferrule[TypTrue]{
{}
}{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\syntrue\typtyped\synbool
}

\inferrule[TypFalse]{
{}
}{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synfalse\typtyped\synbool
}

\inferrule[TypInt]{n\in\mathbb{N}}{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive n\typtyped\synint
}

\inferrule[TypVarLinear]{
{}
}{
\synvar{x}\typtyped\synvar{\tau}\typcomma\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{x}\typtyped\synvar{\tau}
}

\inferrule[TypVarDup]{
{}
}{
\synvar{x}\typtyped\synref\synvar{\tau}\typcomma\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{x}\typtyped\synref\synvar{\tau}
}

\inferrule[TypTupleCons]{
\typctx{\Delta}\typderive\typctx{\Gamma}\typeq\typctx{\Gamma_1}\typcomp\cdots\typcomp\typctx{\Gamma_{n}}\\
\forall i\in[\![1,n]\!],\;\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{e_i}\typtyped\synvar{\mu_i}
}{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive \synlparen \synvar{e_1}\synellipsis\synvar{e_n}\synrparen\typtyped\synlparen\synvar{\mu_1}\synellipsis\synvar{\mu_n}\synrparen
}

\inferrule[TypTupleAccess]{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{e}\typtyped\synlparen\synvar{\mu_1}\synellipsis\synvar{\mu_n}\synrparen\\
i\in[\![1,n]\!]
}{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{e}\syndot i\typtyped \synvar{\mu_i}
}

\inferrule[TypFuncCall]{
\typctx{\Gamma}\typeq\synvar{f}\typtyped\typlparen\typctx{\mu_1}\typellipsis\typctx{\mu_n}\typrparen\typarrow\synvar{\tau}\typcomma\typctx{\Gamma'}\\
\typctx{\Delta}\typderive\typctx{\Gamma}\typeq\typctx{\Gamma_1}\typcomp\cdots\typcomp\typctx{\Gamma_{n}}\\
\forall i\in[\![1,n]\!],\;\typctx{\Gamma_i}\typsc\typctx{\Delta}\typderive\synvar{a_i}\typsym\typctx{\mu_i}\\
}{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{f}\synlparen\synvar{a_1}\synellipsis\synvar{a_n}\synrparen\typtyped\synvar{\tau}
}

\inferrule[TypFunArgLin]{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{e}\typtyped\synvar{\tau}
}{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{e}\typsym\synvar{\tau}
}

\inferrule[TypFunArgDup]{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{e}\typtyped\synvar{\tau}
}{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synref\synvar{e}\typsym\synref\synvar{\tau}
}

\inferrule[TypBinopInt]{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{e_1}\typtyped\synvar{\synint}\\
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{e_2}\typtyped\synvar{\synint}\\
\synvar{\odot}\in\{\synadd,\synminus,\synmult,\syndiv\}
}{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{e_1}\;\synvar{\odot}\;\synvar{e_2}\typtyped\synvar{\synint}
}

\inferrule[TypBinopBool]{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{e_1}\typtyped\synvar{\synbool}\\
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{e_2}\typtyped\synvar{\synbool}\\
\synvar{\odot}\in\{\synand,\synor\}
}{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{e_1}\;\synvar{\odot}\;\synvar{e_2}\typtyped\synvar{\synbool}
}

\inferrule[TypUnopInt]{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{e}\typtyped\synint\\
\oslash\in\{\synminus\}
}{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{\oslash}\;\synvar{e}\typtyped\synint
}

\inferrule[TypUnopBool]{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{e}\typtyped\synbool\\
\oslash\in\{\text{\synnot}\}
}{
\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{\oslash}\;\synvar{e}\typtyped\synbool
}
\end{mathpar}
\end{center}

\begin{center}
\begin{tabular}{lc}\toprule
Statement typing&\typctx{\Gamma}\typsc\typctx{\Delta}\typderive\synvar{s}\typproduce\typctx{\Gamma'}
\\\bottomrule
\end{tabular}
\end{center}

\bibliographystyle{plain}
\bibliography{rustspec.bib}

\end{document}
